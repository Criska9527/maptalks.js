<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>pbr-buildings</title>

  <link rel="stylesheet" href="http://localhost/maptalks/dist/maptalks.css" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="screen.css" />
  <!-- 需要用 maptalks worker 分支下的版本 -->
  <script src="http://localhost/maptalks/dist/maptalks.js"></script>
  <script src="http://localhost/maptalksgl/dist/maptalksgl-dev.js"></script>
  <script src="buildings.js"></script>
  <script src="../../packages/vt/dist/maptalks.vt.js"></script>
  <script src="../../packages/vt.basic/dist/maptalks.vt.basic.js"></script>
  <script src="js/stats.min.js"></script>
  <script src="js/dat.gui.min.js"></script>
</head>

<body>

  <div id="main">
    <div id="map2" style="width:100%;height:1000px;background-color:#ddd;"></div>
    <!-- <canvas id="shadow" width=512 height=512 style="float:left;border:1px red solid"></canvas>
    <canvas id="shadow2" width=512 height=512 style="float:left;border:1px red solid"></canvas> -->

  </div>

  <script>
    var stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild( stats.dom );
    window.MAPTALKS_VT_WORKER_COUNT = 1;


    var osm = new maptalks.TileLayer('osm', {
        crossOrigin : 'anonymous',
        // urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        subdomains: ['a','b','c','d'],
        attribution : '&copy; <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        // urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        //   subdomains: ['a','b','c','d'],
        //   attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
      });

    var map = new maptalks.Map('map2', {
      center: [13.416935229170008, 52.529564137540376],
      zoom: 15,
      pitch : 45,

      "center":[13.422091481252892,52.53081935839131],"zoom":17,"pitch":45,"bearing":0,

      "center":[13.420845330196812,52.53554217055179],"zoom":19,"pitch":33.00000000000021,"bearing":145.20000000000005,

      //阴影有裂缝
      "center":[13.414905354183702,52.52913153292073],"zoom":20,"pitch":33.00000000000021,"bearing":145.20000000000005,

      // bearing : -42,
      // baseLayer: osm
    });
    var id = 0;
    var data = buildings.reduce(function (v, b) {
      for (let i = 0, l = b.features.length; i < l; i++) {
        b.features[i].id = id++;
        v.features.push(b.features[i]);
      }
      return v;
    }, {
      "type" : "FeatureCollection",
      "features" : []
    })


    map.on('framestart', e => {
      stats.begin();
    });

    map.on('frameend', e => {
      stats.end();
    });

    console.log(data.features.length);

    const renderPlugin = {
        type : 'subsurface',
        dataConfig : {
          type : '3d-extrusion',
          altitudeProperty : 'levels',
          altitudeScale : 5,
          defaultAltitude : 1,
          normal : true,
          uv : true,
          uvSize : [128 / 50, 128 / 50],
          // shadowVolume : true,
          // shadowDir : [-1, -1, 0]
        },
        sceneConfig : {
          animation : 'easeOutBounce',
          shadow : {
            type : 'vsm',
            // type : 'stencil',
            enable : true,
            quality : 'medium',
            opacity : 1,
            color : [0, 0, 0],
            blurOffset : 1,
            // debug : ['shadow', 'shadow2']
          },
          lights : {
            ambient: {
              url: 'resources/windowStudio.hdr',
              luminance: 12000
            },
            directional: {
              color : [1, 1, 1],
              direction : [0, 1, 1],
              intensity: 30000
            }
          }
        }
      };

    const litMaterial = {
      'baseColorFactor': [0.560, 0.570, 0.580, 1],
      'metallicFactor' : 0,
      'roughnessFactor' : 0.7,
      'reflectance': 0.5,
      'clearCoat': 0,
      // 'clearCoatNormalTexture': CLEAR_COAT_NORMAL_TEXTURE,
      'clearCoatRoughness': 0.5,
      // 'clearCoatIorChange': false,
      'normalTexture': 'http://localhost/maptalksgl-dev/debug/reshader/ibl/resources/rusted_iron/609-normal.jpg',
      // 'metallicRoughnessTexture': ROUGHNESS_METALLIC_TEXTURE,
      'baseColorTexture': 'http://localhost/maptalksgl-dev/debug/reshader/ibl/resources/rusted_iron/609-normal.jpg',
      'anisotropy': 0,
      'uvScale': [0.5, 0.5],  //纹理坐标的缩放比例
      'uvOffset': [0, 0]      //纹理坐标的偏移量
    };

    const clothMaterial = {
      'roughnessFactor' : 1,
      // 'normalTexture': 'http://localhost/maptalksgl-dev/debug/reshader/ibl/resources/normals/3.jpg',
      // 'baseColorTexture': 'http://localhost/maptalksgl-dev/debug/reshader/ibl/resources/rusted_iron/609-normal.jpg',
      // 'metallicRoughnessTexture': ROUGHNESS_METALLIC_TEXTURE,
      // 'baseColorTexture': BASE_COLOR_TEXTURE,
      'baseColorFactor': [61 / 255, 120 / 255, 12 / 255, 1],
      'subsurfaceColor': [0, 0, 0],
      'uvScale': [0.4, 0.4]
    };

    const subsurfaceMaterial = {
      'roughnessFactor' : 1,
      // 'normalTexture': 'http://localhost/maptalksgl-dev/debug/reshader/ibl/resources/rusted_iron/609-normal.jpg',
      // 'metallicRoughnessTexture': ROUGHNESS_METALLIC_TEXTURE,
      // 'baseColorTexture': BASE_COLOR_TEXTURE,
      'baseColor': [61, 120, 12],
      'baseColorFactor': [61 / 255, 120 / 255, 12 / 255, 1],
      'subsurface': [255, 255, 255],
      'subsurfaceColor': [1, 1, 1],
      'uvScale': [0.3, 0.3],
      'thickness': 0.5,
      'subsurfacePower': 12.234
    };

    const style =  [
      {
        filter : true,
        renderPlugin,
        symbol: {
          material: subsurfaceMaterial,
          polygonOpacity: 1,
          polygonFill: {
            property : 'levels',
            stops : [
              [5, '#f00'],
              [3, '#fff700'],
              [1, '#fff']
            ]
          }
        }
      }
    ];

    // test tile clipping mask
    var layer = new maptalks.GeoJSONVectorTileLayer('polygon1', {
      debug : false,
      // canvas: debugCanvas,
      data: data,
      hitDetect : false,
    });
    layer.setStyle(style);

    // map.on('click', function (e) {
    //   alert(JSON.stringify(layer.identify(e.coordinate)));
    // });

    // map.addLayer(layer);
    new maptalks.GroupGLLayer('group', [layer]).addTo(map);

    map.on('click', e => {
      console.log(JSON.stringify(layer.identify(e.coordinate)));
    });

    initGUI();

    function initGUI() {
      const gui = new dat.GUI( { width: 250 } );
      const options = style[0].symbol.material;
      if (options['metallicFactor'] !== undefined) {
        gui.add(options, 'metallicFactor', 0, 1).onChange(function(value){
          updateMaterial('metallicFactor', value);
        });
        gui.add(options, 'clearCoat', 0, 5).onChange(function(value){
          updateMaterial('clearCoat', value);
        });

        gui.add(options, 'clearCoatRoughness', 0, 1).onChange(function(value){
          updateMaterial('clearCoatRoughness', value);
        });
      }
      gui.add(options, 'roughnessFactor', 0, 1).onChange(function(value){
        updateMaterial('roughnessFactor', value);
      });

      if (options['thickness']) {
        gui.add(options, 'thickness', 0, 1, 0.1).onChange(function(value){
          updateMaterial('thickness', value);
        });

        gui.add(options, 'subsurfacePower', 0, 30, 1).onChange(function(value){
          updateMaterial('subsurfacePower', value);
        });
      }

      gui.addColor(options, 'baseColor').onChange(function(value){
        updateMaterial('baseColor', value);
      });
      if (options['subsurface']) {
        gui.addColor(options, 'subsurface').onChange(function(value){
          updateMaterial('subsurface', value);
        });
      }

    }

    function updateMaterial(key, value) {
      const material = {};
      material[key] = value;
      if (key === 'baseColor') {
        material['baseColorFactor'] = [material.baseColor[0] / 255, material.baseColor[1] / 255, material.baseColor[2] / 255, 1];
      } else if (key === 'subsurface') {
        material['subsurfaceColor'] = [material.subsurface[0] / 255, material.subsurface[1] / 255, material.subsurface[2] / 255];
      }
      layer.updateSymbol(0, {
        material
      });
    }

  </script>
</body>

</html>
