<!DOCTYPE html>
<html>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cube Shadow</title>
  <style type="text/css">
    html,body{margin:0px;height:100%;width:100%}
    .container{width:1000px;height:800px}
  </style>
  <script src="http://localhost/maptalks/dist/maptalks.js" type="text/javascript"></script>
  <script src="../../packages/gl/dist/maptalksgl-dev.js" type="text/javascript"></script>
  <body>
    <canvas id="canvas" width=1000 height=800 class="container" style="border : 1px solid"></canvas>
    <script type="module">
        import cubeData from './common/cube.js';
        import planeData from './common/plane.js';

        const { mat3, mat4, vec3, reshader, createREGL } = maptalksgl;

        const regl = createREGL({
            canvas : canvas,
            extensions : [
                'OES_texture_float',
                'OES_texture_float_linear',
                'OES_element_index_uint',
                'OES_standard_derivatives'
            ]
        });

        const vert = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;

            varying vec3 FragPos;
            varying vec3 Normal;
            varying vec2 TexCoords;

            uniform mat4 viewProjMatrix;
            uniform mat4 modelMatrix;
            uniform mat3 normalMatrix;

            //插入vsm 的 vert 相关代码
            #if defined(USE_SHADOW_MAP)
                #include <vsm_shadow_vert>
            #endif

            void main()
            {
                vec4 pos = vec4(aPosition, 1.0);
                gl_Position = viewProjMatrix * modelMatrix * pos;
                vec4 worldPos = modelMatrix * pos;
                Normal = normalMatrix * aNormal;
                FragPos = vec3(worldPos);

                #ifdef USE_SHADOW_MAP
                    shadow_computeShadowPars(pos);
                #endif
            }
        `;

        const frag = `
            precision mediump float;

            varying vec3 FragPos;
            varying vec3 Normal;

            uniform vec3 diffuseColor;

            // needed by vsm
            // uniform mat4 lightView;
            // uniform mat4 lightProj;

            uniform vec3 lightPos;
            uniform vec3 viewPos;

            //插入 vsm shadow 的frag代码
            #if defined(USE_SHADOW_MAP)
                #include <vsm_shadow_frag>
            #endif

            void main()
            {
                vec3 color = diffuseColor.rgb;
                vec3 normal = normalize(Normal);
                vec3 lightColor = vec3(1.0);
                // Ambient
                vec3 ambient = 0.15 * color;
                // Diffuse
                vec3 lightDir = normalize(lightPos - FragPos);
                float diff = max(dot(lightDir, normal), 0.0);
                vec3 diffuse = diff * lightColor;
                // Specular
                vec3 viewDir = normalize(viewPos - FragPos);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = 0.0;
                vec3 halfwayDir = normalize(lightDir + viewDir);
                spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
                vec3 specular = spec * lightColor;

                float shadow = 0.0;
                #ifdef USE_SHADOW_MAP
                    shadow = shadow_computeShadow();
                #endif

                vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;

                gl_FragColor = vec4(lighting, 1.0);
                // gl_FragColor = vec4(shadow, shadow, shadow, 1.0);
                // gl_FragColor = vec4(moments, 0.0, 1.0);
                // gl_FragColor = vec4(specular, 1.0);
            }
        `;

        const shader = new reshader.MeshShader({
            vert, frag,
            uniforms : [
                'viewProjMatrix',
                'diffuseColor',
                'lightPos', 'viewPos',
                {
                    name : 'normalMatrix',
                    type : 'function',
                    fn : function (context, props) {
                        const normalMatrix = [];
                        const model = props['modelMatrix'];
                        mat4.transpose(normalMatrix, mat4.invert(normalMatrix, model));
                        return mat3.fromMat4([], normalMatrix);
                        // return mat3.fromMat4([], props['modelMatrix']);
                    }
                },
                {
                    // 名称里带[1]，说明是一个1个元素的数组，且在运行时动态计算
                    // vsm_shadow_lightProjViewModelMatrix 是 vsm_shadow_vert中定义的uniform
                    // 值是光源的 lightProjViewMatrix * modelMatrix
                    // lightProjViewMatrix 是一个数组，数组长度 = 光源的数量
                    name : 'vsm_shadow_lightProjViewModelMatrix',
                    type : 'function',
                    fn : function (context, props) {
                        const lightProjViewMatrix = props['lightProjViewMatrix'];
                        const vsmLightProjViewMatrix = mat4.multiply([], lightProjViewMatrix, props['modelMatrix']);

                        return vsmLightProjViewMatrix;
                    }
                },
                //uniforms needed by vsm shadow map
                'vsm_shadow_shadowMap',
                'vsm_shadow_opacity',
                'vsm_shadow_threshold'
            ],
            defines : {
                'USE_SHADOW_MAP' : 1
            }
        });

        const renderer = new reshader.Renderer(regl);
        const SHADOW_RES = 512;
        const shadowPass = new reshader.ShadowPass(renderer, { width : SHADOW_RES, height : SHADOW_RES});

        render();

        function render() {
            const cameraPos = [4, 8, 8];
            const lightPos = [-4.0, 3.0, -1.0];
            const cameraProjViewMatrix = getViewProjection(cameraPos);
            const scene = getScene();

            let { lightProjViewMatrix, shadowMap } = shadowPass.render(scene, { cameraProjViewMatrix, lightDir: lightPos });
            renderer.render(shader, {
                viewProjMatrix : cameraProjViewMatrix,
                diffuseColor : [1, 1, 1],
                lightPos : lightPos,
                viewPos : cameraPos,
                //uniforms needed by vsm shadow map
                vsm_shadow_shadowMap : shadowMap,
                lightProjViewMatrix : lightProjViewMatrix,
                vsm_shadow_opacity: 1,
                vsm_shadow_threshold: 0.0
            }, scene);
        }

        function getScene() {
            const cube = new reshader.Geometry({
                aPosition : cubeData.vertices,
                aNormal : cubeData.normals,
            }, cubeData.indices);
            const plane = new reshader.Geometry({
                aPosition : planeData.vertices,
                aNormal : planeData.normals,
            }, planeData.indices, 0, {
                primitive : 'triangle'
            });

            const cubeMesh = new reshader.Mesh(cube);
            const planeMesh = new reshader.Mesh(plane);
            const planeModel = mat4.identity([]);
            mat4.scale(planeModel, planeModel, [20, 20, 20]);
            planeMesh.setLocalTransform(planeModel);

            const scene = new reshader.Scene([planeMesh, cubeMesh]);
            return scene;
        }

        function getViewProjection(cameraPos) {
            const aspect = canvas.width / canvas.height;
            const projection = mat4.perspective([], 60 * Math.PI / 180, aspect, 1, 20);
            const view = mat4.lookAt([], cameraPos, [0, 0, 0], [0, 1, 0]);
            const viewProjection = mat4.multiply([], projection, view);
            return viewProjection;
        }


    </script>
  </body>
</html>
