<!DOCTYPE html>
<html>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Red Cube</title>
  <style type="text/css">
    html,body{margin:0px;height:100%;width:100%}
    .container{width:1000px;height:800px}
  </style>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/maptalks/dist/maptalks.js"></script>
    <script src="../../packages/gl/dist/maptalksgl-dev.js" type="text/javascript"></script>
    <script src="js/gltf-loader-dev.js" type="text/javascript"></script>
  <body>
    <canvas id="canvas" width=1000 height=800 class="container" style="border : 1px solid"></canvas>
    <!-- <script src="./common/regl.js" type="text/javascript"></script> -->
    <script type="module">

        const { createREGL, mat4, reshader } = maptalksgl;
        const MODES = ['points', 'lines', 'line strip', 'line loop', 'triangles', 'triangle strip', 'triangle fan'];

        const regl = createREGL({
            canvas : canvas,
            extensions : [
                'OES_texture_float',
                'OES_element_index_uint',
                'OES_standard_derivatives',
                'EXT_shader_texture_lod'
            ]
        });
        let iblMaps;

        const loader = new reshader.ResourceLoader(regl.texture(2));
        const renderer = new reshader.Renderer(regl);
        const camPos = [0, 2, 18];

        function main() {
            //载入环境光纹理
            const hdr = new reshader.Texture2D(
                {
                    url : './ibl/resources/env.hdr',
                    arrayBuffer : true,
                    hdr : true,
                    type : 'float',
                    format : 'rgba',
                    flipY : true
                },
                loader
            );
            if (!hdr.isReady()) {
                loader.on('complete', function () {
                    if (hdr.isReady()) {
                        //环境光纹理载入，重新生成ibl纹理
                        iblMaps = createMaps(hdr);
                    }
                    render();
                });
            } else {
                //生成ibl纹理
                iblMaps = createMaps(hdr);
                render();
            }
        }
        main();
        function render() {
            //生成相机矩阵
            const { viewMatrix, projMatrix } = getViewProjection(camPos, canvas.width / canvas.height);
            //绘制gltf模型
            drawGLTFModel(viewMatrix, projMatrix);
        }
        function drawGLTFModel(viewMatrix, projMatrix) {
            const projViewMatrix = mat4.multiply([], projMatrix, viewMatrix);
            const shader = new reshader.pbr.LitShader({
                positionAttribute : 'POSITION',
                normalAttribute : 'NORMAL',
                tangentAttribute : 'TANGENT',
                colorAttribute : 'COLOR_0',
                uv0Attribute : 'TEXCOORD_0',
                uv1Attribute : 'TEXCOORD_1'
            });
            const scenePromise = getScene();
            scenePromise.then(scene => {
                renderer.render(
                    shader,
                    {
                        viewMatrix,
                        projViewMatrix,

                        'light_iblDFG': iblMaps.dfgLUT,
                        'light_iblSpecular': iblMaps.prefilterMap,

                        'resolution': [canvas.width, canvas.height, 1 / canvas.width, 1 / canvas.height],
                        'cameraPosition':camPos,
                        'iblSH': iblMaps.sh,
                        'time': Date.now() / 1000,

                        'lightColorIntensity': [1, 1, 1, 1],
                        'sun': [1, 1, 1, 1],
                        'lightDirection': [1, 1, 1],
                        'iblLuminance': 1,
                        'exposure': 1,
                        'ev100': 0,
                    },
                    scene
                );
                reshader.SkyboxHelper.drawSkybox(regl, iblMaps.envMap, viewMatrix, projMatrix, true);
            });

        }

        function createMaps(hdr) {
            return reshader.pbr.PBRHelper.createIBLMaps(regl, {
                envTexture : hdr.getREGLTexture(regl)
            });
        }
        function getScene() {
            var url = 'gltf/AnimatedMorphCube/AnimatedMorphCube.gltf';
            return gltf.Ajax.getJSON(url, {}).then((json) => {
                const loader = new gltf.GLTFLoader('gltf/AnimatedMorphCube', json);
                return loader.load().then(gltfData => {
                    console.log(gltfData);
                    const transformMat = mat4.identity([]);
                    mat4.rotate(transformMat,transformMat,90,[1,0,0]);
                    const modelMeshes = [];
                    const nodes = gltfData.scenes[0].nodes;
                    nodes.forEach((node, i) => {
                        if (!node.meshes && !node.children) {
                            return;
                        }
                        let meshes = null;
                        if (node.children) {
                            meshes = extractMesh(node.children);
                        } else if (node.meshes) {
                            meshes = node.meshes;
                        }
                        meshes.forEach(mesh => {
                            mesh.primitives.forEach(primitive => {
                                const modelGeometry = createGeometry(primitive);
                                const defines = getGeometryDefines(modelGeometry);
                                const material = new reshader.pbr.LitMaterial();
                                //modelGeometry.generateBuffers(this.regl);//会抛elements must be array to build unique vertex.的异常，
                                const modelMesh = new reshader.Mesh(modelGeometry, material);
                                modelMeshes.push(modelMesh);
                                modelMesh.setLocalTransform(transformMat);
                                modelMesh.setDefines(defines);
                            });
                        });
                    });
                    const scene = new reshader.Scene(modelMeshes);
                    return scene;
                });
            });
        }

        function createGeometry(primitive) {
            const attributes = {};
            for (const attr in primitive.attributes) {
                attributes[attr] =  primitive.attributes[attr].array;
            }
            const modelGeometry = new reshader.Geometry(
                attributes,
                primitive.indices,
                0,
                {
                    //绘制类型，例如 triangle strip, line等，根据gltf中primitive的mode来判断，默认是triangles
                    primitive : maptalks.Util.isNumber(primitive.mode) ? MODES[primitive.mode] : primitive.mode,
                    positionAttribute : 'POSITION',
                }
            );
            return modelGeometry;
        }

        function getViewProjection(cameraPos, aspect) {
            const projMatrix = mat4.perspective([], 60 * Math.PI / 180, aspect, 1, 200);
            const viewMatrix = mat4.lookAt([], cameraPos, [0, 0, 0], [0, 1, 0]);
            return {
                viewMatrix,
                projMatrix
            };
        }
        function getGeometryDefines(geometry) {
            const defines = {};
            if (geometry.data['TANGENT']) {
                defines['HAS_ATTRIBUTE_TANGENTS'] = 1;
            }
            if (geometry.data['COLOR_0']) {
                defines['HAS_COLOR'] = 1;
                defines['HAS_ATTRIBUTE_COLOR'] = 1;
            }
            if (geometry.data['TEXCOORD_0']) {
                defines['HAS_ATTRIBUTE_UV0'] = 1;
            }
            if (geometry.data['TEXCOORD_1']) {
                defines['HAS_ATTRIBUTE_UV1'] = 1;
            }
            return defines;
    }
    </script>
  </body>
</html>
