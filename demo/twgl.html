<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no' />
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>twgl adapter</title>
    <!-- twgl -->
    <script src="../node_modules/twgl.js/dist/3.x/twgl-full.js"></script>
    <!-- fusion.gl -->
    <script src="../dist/bundle.js"></script>
</head>

<body>
    <canvas id="cvs" style="width:800px;height:600px;"></canvas>
    <script>
        // vertex shader
      const vs = 'precision mediump float;' + '\n' +
        'uniform mat4 u_worldViewProjection;' + '\n' +
        'uniform vec3 u_lightWorldPos;' + '\n' +
        'uniform mat4 u_world;' + '\n' +
        'uniform mat4 u_viewInverse;' + '\n' +
        'uniform mat4 u_worldInverseTranspose;' + '\n' +
        'attribute vec4 position;' + '\n' +
        'attribute vec3 normal;' + '\n' +
        'attribute vec2 texcoord;' + '\n' +
        'varying vec4 v_position;' + '\n' +
        'varying vec2 v_texCoord;' + '\n' +
        'varying vec3 v_normal;' + '\n' +
        'varying vec3 v_surfaceToLight;' + '\n' +
        'varying vec3 v_surfaceToView;' + '\n' +
        'void main() {' + '\n' +
        'v_texCoord = texcoord;' + '\n' +
        'v_position = u_worldViewProjection * position;' + '\n' +
        'v_normal = (u_worldInverseTranspose * vec4(normal, 0)).xyz;' + '\n' +
        'v_surfaceToLight = u_lightWorldPos - (u_world * position).xyz;' + '\n' +
        'v_surfaceToView = (u_viewInverse[3] - (u_world * position)).xyz;' + '\n' +
        'gl_Position = v_position;' + '\n' +
        '}';
        //fragment shader
      const fs = 'precision mediump float;' + '\n' +
        'varying vec4 v_position;' + '\n' +
        'varying vec2 v_texCoord;' + '\n' +
        'varying vec3 v_normal;' + '\n' +
        'varying vec3 v_surfaceToLight;' + '\n' +
        'varying vec3 v_surfaceToView;' + '\n' +
        'uniform vec4 u_lightColor;' + '\n' +
        'uniform vec4 u_ambient;' + '\n' +
        'uniform sampler2D u_diffuse;' + '\n' +
        'uniform vec4 u_specular;' + '\n' +
        'uniform float u_shininess;' + '\n' +
        'uniform float u_specularFactor;' + '\n' +
        'vec4 lit(float l ,float h, float m) {' + '\n' +
        'return vec4(1.0,max(l, 0.0),(l > 0.0) ? pow(max(0.0, h), m) : 0.0,1.0);' + '\n' +
        '}' + '\n' +
        'void main() {' + '\n' +
        'vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);' + '\n' +
        'vec3 a_normal = normalize(v_normal);' + '\n' +
        'vec3 surfaceToLight = normalize(v_surfaceToLight);' + '\n' +
        'vec3 surfaceToView = normalize(v_surfaceToView);' + '\n' +
        'vec3 halfVector = normalize(surfaceToLight + surfaceToView);' + '\n' +
        'vec4 litR = lit(dot(a_normal, surfaceToLight),' + '\n' +
        'dot(a_normal, halfVector), u_shininess);' + '\n' +
        'vec4 outColor = vec4((u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient + u_specular * litR.z * u_specularFactor)).rgb,diffuseColor.a);' + '\n' +
        'gl_FragColor = outColor;' + '\n' +
        '}';
        //canva documentElement
        const canvas = document.getElementById('cvs'),
            glCanvas = new Fusion.gl.GLCanvas(canvas),
            gl = glCanvas.getContext('webgl'),
            programInfo = twgl.createProgramInfo(gl, [vs, fs]),
            //object data
            arrays = {
                position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],
                normal: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
                texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
                indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],
            },
            bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays),
            //texture data
            tex = twgl.createTexture(gl, {
                min: gl.NEAREST,
                mag: gl.NEAREST,
                src: [
                    255, 255, 255, 255,
                    192, 192, 192, 255,
                    192, 192, 192, 255,
                    255, 255, 255, 255,
                ],
            }),
            //uniforms data
            uniforms = {
                u_lightWorldPos: [1, 8, -10],
                u_lightColor: [1, 0.8, 0.8, 1],
                u_ambient: [0, 0, 0, 1],
                u_specular: [1, 1, 1, 1],
                u_shininess: 50,
                u_specularFactor: 1,
                u_diffuse: tex,
            };

        twgl.resizeCanvasToDisplaySize(gl.canvas);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const render = function (time) {
            time = time * 0.001;
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const fov = 30 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.5;
            const zFar = 10;
            const projection = twgl.m4.perspective(fov, aspect, zNear, zFar);
            const eye = [1, 4, -6];
            const target = [0, 0, 0];
            const up = [0, 1, 0];

            const camera = twgl.m4.lookAt(eye, target, up);
            const view = twgl.m4.inverse(camera);
            const viewProjection = twgl.m4.multiply(projection, view);
            const world = twgl.m4.rotationY(time);

            uniforms.u_viewInverse = camera;
            uniforms.u_world = world;
            uniforms.u_worldInverseTranspose = twgl.m4.transpose(twgl.m4.inverse(world));
            uniforms.u_worldViewProjection = twgl.m4.multiply(viewProjection, world);

            gl.useProgram(programInfo.program);
            twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
            twgl.setUniforms(programInfo, uniforms);
            gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    </script>
</body>

</html>
